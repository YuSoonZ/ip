package theadvisor;

import java.io.IOException;
import java.io.Serializable;
import java.time.DateTimeException;
import java.time.LocalDateTime;

/**
 * TheAdvisor class represents the main application that manages tasks.
 * It interacts with the user interface, task list, and storage to handle user commands.
 */
public class TheAdvisor implements Serializable {
    private static final String FILE_PATH = "list.bin";

    private Ui ui;

    private Storage storage;

    private TaskList taskList;

    /**
     * Constructs a new TheAdvisor instance with default settings.
     */
    public TheAdvisor() {
        this.ui = new Ui();
        this.storage = new Storage(FILE_PATH);
        try {
            taskList = storage.loadList();
            if (taskList == null) {
                taskList = new TaskList();
            }
        } catch (IOException err) {
            System.out.println("No list found, creating empty task list");
            taskList = new TaskList();
        } catch (ClassNotFoundException err) {
            System.out.println("Class mismatch. Check and try again");
            taskList = new TaskList();
        }
    }

    /**
     * Processes the user input and returns the appropriate response.
     *
     * @param req The user input string.
     * @return The response generated by the application.
     */
    public String getResponse(String req) {
        String[] strings = req.split(" ");
        Parser.Prompts prompt = Parser.parsePrompt(strings[0]);
        String response = "";
        try {
            switch (prompt) {
            case BYE:
                response = ui.goodbye();
                break;
            case LIST:
                response = ui.printList(taskList);
                break;
            case MARK:
                response = markTaskResponse(strings);
                break;
            case UNMARK:
                response = unmarkTaskResponse(strings);
                break;
            case DELETE:
                response = deleteResponse(strings);
                break;
            case TODO:
                String todo = req.substring(4);
                response = todoRequest(todo);
                break;
            case DEADLINE:
                String due = req.substring(8);
                String[] arrTask = due.split(" /by ");
                response = deadlineRequest(arrTask);
                break;
            case EVENT:
                String event = req.substring(5);
                String[] eventArr = event.split(" /from ");
                response = eventRequest(eventArr);
                break;
            case FIND:
                String keyword = req.substring(5);
                response = findRequest(keyword);
                break;
            case WRONG:
                response = "Incorrect prompt use. Please try again with these prompts: "
                        + "todo, list, mark, unmark, bye, event, deadline, find";
                break;
            default:
                throw new TheAdvisorException("Incorrect input, please try again with the correct input of either: "
                        + "todo, event, mark...etc");
            }
        } catch (TheAdvisorException e) {
            System.out.println("Error: " + e.getMessage());
        }
        return response;
    }
    private String markTaskResponse(String[] str) {
        String response;
        if (checkArrayLength(2, str)) {
            response = taskList.markTask(Integer.parseInt(str[1]) - 1);
            storage.saveTasks(taskList);
            return response;
        } else {
            response = "Invalid format. Make sure that the format is: "
                    + "mark + (number) to mark something on the list as completed.";
        }
        return response;
    }
    private String unmarkTaskResponse(String[] str) {
        String response;
        if (checkArrayLength(2, str)) {
            response = taskList.unmarkTask(Integer.parseInt(str[1]) - 1);
            storage.saveTasks(taskList);
            return response;
        } else {
            response = "Invalid format. Make sure that the format is: "
                    + "unmark + (number) to unmark something on the list.";
        }
        return response;
    }
    private String deleteResponse(String[] str) {
        String response;
        if (checkArrayLength(2, str)) {
            response = taskList.deleteFromList(Integer.parseInt(str[1]) - 1);
            storage.saveTasks(taskList);
        } else {
            response = "Invalid format. Make sure that the format is: "
                    + "delete + (number) to delete something from the list.";
        }
        return response;
    }
    private String todoRequest(String todo) {
        String response;
        if (emptyDescription(todo)) {
            response = "The description for todo cannot be empty. "
                    + "The input should be <todo> + description";
        } else {
            ToDos toDos = new ToDos(todo);
            response = taskList.addToList(toDos);
            storage.saveTasks(taskList);
        }
        return response;
    }
    private String deadlineRequest(String[] arrTask) throws TheAdvisorException {
        String response;
        if (checkArrayLength(2, arrTask)) {
            try {
                Deadline deadline = new Deadline(arrTask[0], LocalDateTime.parse(arrTask[1],
                        Task.INPUT_FORMAT));
                response = taskList.addToList(deadline);
                storage.saveTasks(taskList);
            } catch (DateTimeException e) {
                response = "Incorrect format of your timestamp! Please input YYYY-MM-DD HHmm";
            }
        } else {
            response = "Invalid deadline format. Please use the correct format: deadline + description + /by +"
                    + " <YYYY-MM-DD HHmm>";
        }
        return response;
    }
    private String eventRequest(String[] eventArr) throws TheAdvisorException {
        String response;
        if (checkArrayLength(2, eventArr)) {
            try {
                String[] time = eventArr[1].split(" /to");
                String startStr = time[0].trim();
                String endStr = time[1].trim();
                LocalDateTime start = LocalDateTime.parse(startStr, Task.INPUT_FORMAT);
                LocalDateTime end = LocalDateTime.parse(endStr, Task.INPUT_FORMAT);
                Events events = new Events(eventArr[0], start, end);
                response = taskList.addToList(events);
                storage.saveTasks(taskList);
            } catch (DateTimeException e) {
                response = "Incorrect format of your timestamp! Please input YYYY-MM-DD HHmm";
            }
        } else {
            response = "Invalid event format. " + "The input should be <event> + description + "
                    + "/from <YYYY-MM-DD HHmm> + " + "/to <YYYY-MM-DD HHmm>";
        }
        return response;
    }
    private String findRequest(String keyword) throws TheAdvisorException {
        String response;
        if (emptyDescription(keyword)) {
            response = "Please key in the keyword of what you wish "
                    + "to find please!";
        } else {
            response = taskList.findItem(keyword);
        }
        return response;
    }
    private static boolean emptyDescription(String description) {
        return description.isEmpty();
    }

    private static boolean checkArrayLength(int expectedLength, String... array) {
        return array.length == expectedLength;
    }
}
